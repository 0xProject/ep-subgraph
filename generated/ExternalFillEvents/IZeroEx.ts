// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class LimitOrderFilled extends ethereum.Event {
  get params(): LimitOrderFilled__Params {
    return new LimitOrderFilled__Params(this);
  }
}

export class LimitOrderFilled__Params {
  _event: LimitOrderFilled;

  constructor(event: LimitOrderFilled) {
    this._event = event;
  }

  get orderHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get maker(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get taker(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get feeRecipient(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get makerToken(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get takerToken(): Address {
    return this._event.parameters[5].value.toAddress();
  }

  get takerTokenFilledAmount(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }

  get makerTokenFilledAmount(): BigInt {
    return this._event.parameters[7].value.toBigInt();
  }

  get takerTokenFeeFilledAmount(): BigInt {
    return this._event.parameters[8].value.toBigInt();
  }

  get protocolFeePaid(): BigInt {
    return this._event.parameters[9].value.toBigInt();
  }

  get pool(): Bytes {
    return this._event.parameters[10].value.toBytes();
  }
}

export class LiquidityProviderSwap extends ethereum.Event {
  get params(): LiquidityProviderSwap__Params {
    return new LiquidityProviderSwap__Params(this);
  }
}

export class LiquidityProviderSwap__Params {
  _event: LiquidityProviderSwap;

  constructor(event: LiquidityProviderSwap) {
    this._event = event;
  }

  get inputToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get outputToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get inputTokenAmount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get outputTokenAmount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get provider(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get recipient(): Address {
    return this._event.parameters[5].value.toAddress();
  }
}

export class MetaTransactionExecuted extends ethereum.Event {
  get params(): MetaTransactionExecuted__Params {
    return new MetaTransactionExecuted__Params(this);
  }
}

export class MetaTransactionExecuted__Params {
  _event: MetaTransactionExecuted;

  constructor(event: MetaTransactionExecuted) {
    this._event = event;
  }

  get hash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get selector(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get signer(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get sender(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class Migrated extends ethereum.Event {
  get params(): Migrated__Params {
    return new Migrated__Params(this);
  }
}

export class Migrated__Params {
  _event: Migrated;

  constructor(event: Migrated) {
    this._event = event;
  }

  get caller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get migrator(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class OrderCancelled extends ethereum.Event {
  get params(): OrderCancelled__Params {
    return new OrderCancelled__Params(this);
  }
}

export class OrderCancelled__Params {
  _event: OrderCancelled;

  constructor(event: OrderCancelled) {
    this._event = event;
  }

  get orderHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get maker(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class PairCancelledLimitOrders extends ethereum.Event {
  get params(): PairCancelledLimitOrders__Params {
    return new PairCancelledLimitOrders__Params(this);
  }
}

export class PairCancelledLimitOrders__Params {
  _event: PairCancelledLimitOrders;

  constructor(event: PairCancelledLimitOrders) {
    this._event = event;
  }

  get maker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get makerToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get takerToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get minValidSalt(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class PairCancelledRfqOrders extends ethereum.Event {
  get params(): PairCancelledRfqOrders__Params {
    return new PairCancelledRfqOrders__Params(this);
  }
}

export class PairCancelledRfqOrders__Params {
  _event: PairCancelledRfqOrders;

  constructor(event: PairCancelledRfqOrders) {
    this._event = event;
  }

  get maker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get makerToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get takerToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get minValidSalt(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class ProxyFunctionUpdated extends ethereum.Event {
  get params(): ProxyFunctionUpdated__Params {
    return new ProxyFunctionUpdated__Params(this);
  }
}

export class ProxyFunctionUpdated__Params {
  _event: ProxyFunctionUpdated;

  constructor(event: ProxyFunctionUpdated) {
    this._event = event;
  }

  get selector(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get oldImpl(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get newImpl(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class QuoteSignerUpdated extends ethereum.Event {
  get params(): QuoteSignerUpdated__Params {
    return new QuoteSignerUpdated__Params(this);
  }
}

export class QuoteSignerUpdated__Params {
  _event: QuoteSignerUpdated;

  constructor(event: QuoteSignerUpdated) {
    this._event = event;
  }

  get quoteSigner(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class RfqOrderFilled extends ethereum.Event {
  get params(): RfqOrderFilled__Params {
    return new RfqOrderFilled__Params(this);
  }
}

export class RfqOrderFilled__Params {
  _event: RfqOrderFilled;

  constructor(event: RfqOrderFilled) {
    this._event = event;
  }

  get orderHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get maker(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get taker(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get makerToken(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get takerToken(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get takerTokenFilledAmount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get makerTokenFilledAmount(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }

  get pool(): Bytes {
    return this._event.parameters[7].value.toBytes();
  }
}

export class RfqOrderOriginsAllowed extends ethereum.Event {
  get params(): RfqOrderOriginsAllowed__Params {
    return new RfqOrderOriginsAllowed__Params(this);
  }
}

export class RfqOrderOriginsAllowed__Params {
  _event: RfqOrderOriginsAllowed;

  constructor(event: RfqOrderOriginsAllowed) {
    this._event = event;
  }

  get origin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get addrs(): Array<Address> {
    return this._event.parameters[1].value.toAddressArray();
  }

  get allowed(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class TransformedERC20 extends ethereum.Event {
  get params(): TransformedERC20__Params {
    return new TransformedERC20__Params(this);
  }
}

export class TransformedERC20__Params {
  _event: TransformedERC20;

  constructor(event: TransformedERC20) {
    this._event = event;
  }

  get taker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get inputToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get outputToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get inputTokenAmount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get outputTokenAmount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class TransformerDeployerUpdated extends ethereum.Event {
  get params(): TransformerDeployerUpdated__Params {
    return new TransformerDeployerUpdated__Params(this);
  }
}

export class TransformerDeployerUpdated__Params {
  _event: TransformerDeployerUpdated;

  constructor(event: TransformerDeployerUpdated) {
    this._event = event;
  }

  get transformerDeployer(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class IZeroEx___fillRfqOrderResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class IZeroEx___fillRfqOrderInputOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class IZeroEx___fillRfqOrderInputSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class IZeroEx__batchGetLimitOrderRelevantStatesResultOrderInfosStruct extends ethereum.Tuple {
  get orderHash(): Bytes {
    return this[0].toBytes();
  }

  get status(): i32 {
    return this[1].toI32();
  }

  get takerTokenFilledAmount(): BigInt {
    return this[2].toBigInt();
  }
}

export class IZeroEx__batchGetLimitOrderRelevantStatesResult {
  value0: Array<
    IZeroEx__batchGetLimitOrderRelevantStatesResultOrderInfosStruct
  >;
  value1: Array<BigInt>;
  value2: Array<boolean>;

  constructor(
    value0: Array<
      IZeroEx__batchGetLimitOrderRelevantStatesResultOrderInfosStruct
    >,
    value1: Array<BigInt>,
    value2: Array<boolean>
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromTupleArray(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigIntArray(this.value1));
    map.set("value2", ethereum.Value.fromBooleanArray(this.value2));
    return map;
  }
}

export class IZeroEx__batchGetLimitOrderRelevantStatesInputOrdersStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[4].toBigInt();
  }

  get maker(): Address {
    return this[5].toAddress();
  }

  get taker(): Address {
    return this[6].toAddress();
  }

  get sender(): Address {
    return this[7].toAddress();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get pool(): Bytes {
    return this[9].toBytes();
  }

  get expiry(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }
}

export class IZeroEx__batchGetLimitOrderRelevantStatesInputSignaturesStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class IZeroEx__batchGetRfqOrderRelevantStatesResultOrderInfosStruct extends ethereum.Tuple {
  get orderHash(): Bytes {
    return this[0].toBytes();
  }

  get status(): i32 {
    return this[1].toI32();
  }

  get takerTokenFilledAmount(): BigInt {
    return this[2].toBigInt();
  }
}

export class IZeroEx__batchGetRfqOrderRelevantStatesResult {
  value0: Array<IZeroEx__batchGetRfqOrderRelevantStatesResultOrderInfosStruct>;
  value1: Array<BigInt>;
  value2: Array<boolean>;

  constructor(
    value0: Array<
      IZeroEx__batchGetRfqOrderRelevantStatesResultOrderInfosStruct
    >,
    value1: Array<BigInt>,
    value2: Array<boolean>
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromTupleArray(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigIntArray(this.value1));
    map.set("value2", ethereum.Value.fromBooleanArray(this.value2));
    return map;
  }
}

export class IZeroEx__batchGetRfqOrderRelevantStatesInputOrdersStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class IZeroEx__batchGetRfqOrderRelevantStatesInputSignaturesStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class IZeroEx__fillOrKillRfqOrderInputOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class IZeroEx__fillOrKillRfqOrderInputSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class IZeroEx__fillRfqOrderResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class IZeroEx__fillRfqOrderInputOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class IZeroEx__fillRfqOrderInputSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class IZeroEx__getLimitOrderHashInputOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[4].toBigInt();
  }

  get maker(): Address {
    return this[5].toAddress();
  }

  get taker(): Address {
    return this[6].toAddress();
  }

  get sender(): Address {
    return this[7].toAddress();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get pool(): Bytes {
    return this[9].toBytes();
  }

  get expiry(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }
}

export class IZeroEx__getLimitOrderInfoResultOrderInfoStruct extends ethereum.Tuple {
  get orderHash(): Bytes {
    return this[0].toBytes();
  }

  get status(): i32 {
    return this[1].toI32();
  }

  get takerTokenFilledAmount(): BigInt {
    return this[2].toBigInt();
  }
}

export class IZeroEx__getLimitOrderInfoInputOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[4].toBigInt();
  }

  get maker(): Address {
    return this[5].toAddress();
  }

  get taker(): Address {
    return this[6].toAddress();
  }

  get sender(): Address {
    return this[7].toAddress();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get pool(): Bytes {
    return this[9].toBytes();
  }

  get expiry(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }
}

export class IZeroEx__getLimitOrderRelevantStateResultOrderInfoStruct extends ethereum.Tuple {
  get orderHash(): Bytes {
    return this[0].toBytes();
  }

  get status(): i32 {
    return this[1].toI32();
  }

  get takerTokenFilledAmount(): BigInt {
    return this[2].toBigInt();
  }
}

export class IZeroEx__getLimitOrderRelevantStateResult {
  value0: IZeroEx__getLimitOrderRelevantStateResultOrderInfoStruct;
  value1: BigInt;
  value2: boolean;

  constructor(
    value0: IZeroEx__getLimitOrderRelevantStateResultOrderInfoStruct,
    value1: BigInt,
    value2: boolean
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromTuple(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromBoolean(this.value2));
    return map;
  }
}

export class IZeroEx__getLimitOrderRelevantStateInputOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[4].toBigInt();
  }

  get maker(): Address {
    return this[5].toAddress();
  }

  get taker(): Address {
    return this[6].toAddress();
  }

  get sender(): Address {
    return this[7].toAddress();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get pool(): Bytes {
    return this[9].toBytes();
  }

  get expiry(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }
}

export class IZeroEx__getLimitOrderRelevantStateInputSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class IZeroEx__getMetaTransactionExecutedBlockInputMtxStruct extends ethereum.Tuple {
  get signer(): Address {
    return this[0].toAddress();
  }

  get sender(): Address {
    return this[1].toAddress();
  }

  get minGasPrice(): BigInt {
    return this[2].toBigInt();
  }

  get maxGasPrice(): BigInt {
    return this[3].toBigInt();
  }

  get expirationTimeSeconds(): BigInt {
    return this[4].toBigInt();
  }

  get salt(): BigInt {
    return this[5].toBigInt();
  }

  get callData(): Bytes {
    return this[6].toBytes();
  }

  get value(): BigInt {
    return this[7].toBigInt();
  }

  get feeToken(): Address {
    return this[8].toAddress();
  }

  get feeAmount(): BigInt {
    return this[9].toBigInt();
  }
}

export class IZeroEx__getMetaTransactionHashInputMtxStruct extends ethereum.Tuple {
  get signer(): Address {
    return this[0].toAddress();
  }

  get sender(): Address {
    return this[1].toAddress();
  }

  get minGasPrice(): BigInt {
    return this[2].toBigInt();
  }

  get maxGasPrice(): BigInt {
    return this[3].toBigInt();
  }

  get expirationTimeSeconds(): BigInt {
    return this[4].toBigInt();
  }

  get salt(): BigInt {
    return this[5].toBigInt();
  }

  get callData(): Bytes {
    return this[6].toBytes();
  }

  get value(): BigInt {
    return this[7].toBigInt();
  }

  get feeToken(): Address {
    return this[8].toAddress();
  }

  get feeAmount(): BigInt {
    return this[9].toBigInt();
  }
}

export class IZeroEx__getRfqOrderHashInputOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class IZeroEx__getRfqOrderInfoResultOrderInfoStruct extends ethereum.Tuple {
  get orderHash(): Bytes {
    return this[0].toBytes();
  }

  get status(): i32 {
    return this[1].toI32();
  }

  get takerTokenFilledAmount(): BigInt {
    return this[2].toBigInt();
  }
}

export class IZeroEx__getRfqOrderInfoInputOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class IZeroEx__getRfqOrderRelevantStateResultOrderInfoStruct extends ethereum.Tuple {
  get orderHash(): Bytes {
    return this[0].toBytes();
  }

  get status(): i32 {
    return this[1].toI32();
  }

  get takerTokenFilledAmount(): BigInt {
    return this[2].toBigInt();
  }
}

export class IZeroEx__getRfqOrderRelevantStateResult {
  value0: IZeroEx__getRfqOrderRelevantStateResultOrderInfoStruct;
  value1: BigInt;
  value2: boolean;

  constructor(
    value0: IZeroEx__getRfqOrderRelevantStateResultOrderInfoStruct,
    value1: BigInt,
    value2: boolean
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromTuple(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromBoolean(this.value2));
    return map;
  }
}

export class IZeroEx__getRfqOrderRelevantStateInputOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class IZeroEx__getRfqOrderRelevantStateInputSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class IZeroEx extends ethereum.SmartContract {
  static bind(address: Address): IZeroEx {
    return new IZeroEx("IZeroEx", address);
  }

  _fillRfqOrder(
    order: IZeroEx___fillRfqOrderInputOrderStruct,
    signature: IZeroEx___fillRfqOrderInputSignatureStruct,
    takerTokenFillAmount: BigInt,
    taker: Address
  ): IZeroEx___fillRfqOrderResult {
    let result = super.call(
      "_fillRfqOrder",
      "_fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address):(uint128,uint128)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromTuple(signature),
        ethereum.Value.fromUnsignedBigInt(takerTokenFillAmount),
        ethereum.Value.fromAddress(taker)
      ]
    );

    return new IZeroEx___fillRfqOrderResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try__fillRfqOrder(
    order: IZeroEx___fillRfqOrderInputOrderStruct,
    signature: IZeroEx___fillRfqOrderInputSignatureStruct,
    takerTokenFillAmount: BigInt,
    taker: Address
  ): ethereum.CallResult<IZeroEx___fillRfqOrderResult> {
    let result = super.tryCall(
      "_fillRfqOrder",
      "_fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address):(uint128,uint128)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromTuple(signature),
        ethereum.Value.fromUnsignedBigInt(takerTokenFillAmount),
        ethereum.Value.fromAddress(taker)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new IZeroEx___fillRfqOrderResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  batchGetLimitOrderRelevantStates(
    orders: Array<IZeroEx__batchGetLimitOrderRelevantStatesInputOrdersStruct>,
    signatures: Array<
      IZeroEx__batchGetLimitOrderRelevantStatesInputSignaturesStruct
    >
  ): IZeroEx__batchGetLimitOrderRelevantStatesResult {
    let result = super.call(
      "batchGetLimitOrderRelevantStates",
      "batchGetLimitOrderRelevantStates((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256)[],(uint8,uint8,bytes32,bytes32)[]):((bytes32,uint8,uint128)[],uint128[],bool[])",
      [
        ethereum.Value.fromTupleArray(orders),
        ethereum.Value.fromTupleArray(signatures)
      ]
    );

    return new IZeroEx__batchGetLimitOrderRelevantStatesResult(
      result[0].toTupleArray<
        IZeroEx__batchGetLimitOrderRelevantStatesResultOrderInfosStruct
      >(),
      result[1].toBigIntArray(),
      result[2].toBooleanArray()
    );
  }

  try_batchGetLimitOrderRelevantStates(
    orders: Array<IZeroEx__batchGetLimitOrderRelevantStatesInputOrdersStruct>,
    signatures: Array<
      IZeroEx__batchGetLimitOrderRelevantStatesInputSignaturesStruct
    >
  ): ethereum.CallResult<IZeroEx__batchGetLimitOrderRelevantStatesResult> {
    let result = super.tryCall(
      "batchGetLimitOrderRelevantStates",
      "batchGetLimitOrderRelevantStates((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256)[],(uint8,uint8,bytes32,bytes32)[]):((bytes32,uint8,uint128)[],uint128[],bool[])",
      [
        ethereum.Value.fromTupleArray(orders),
        ethereum.Value.fromTupleArray(signatures)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new IZeroEx__batchGetLimitOrderRelevantStatesResult(
        value[0].toTupleArray<
          IZeroEx__batchGetLimitOrderRelevantStatesResultOrderInfosStruct
        >(),
        value[1].toBigIntArray(),
        value[2].toBooleanArray()
      )
    );
  }

  batchGetRfqOrderRelevantStates(
    orders: Array<IZeroEx__batchGetRfqOrderRelevantStatesInputOrdersStruct>,
    signatures: Array<
      IZeroEx__batchGetRfqOrderRelevantStatesInputSignaturesStruct
    >
  ): IZeroEx__batchGetRfqOrderRelevantStatesResult {
    let result = super.call(
      "batchGetRfqOrderRelevantStates",
      "batchGetRfqOrderRelevantStates((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256)[],(uint8,uint8,bytes32,bytes32)[]):((bytes32,uint8,uint128)[],uint128[],bool[])",
      [
        ethereum.Value.fromTupleArray(orders),
        ethereum.Value.fromTupleArray(signatures)
      ]
    );

    return new IZeroEx__batchGetRfqOrderRelevantStatesResult(
      result[0].toTupleArray<
        IZeroEx__batchGetRfqOrderRelevantStatesResultOrderInfosStruct
      >(),
      result[1].toBigIntArray(),
      result[2].toBooleanArray()
    );
  }

  try_batchGetRfqOrderRelevantStates(
    orders: Array<IZeroEx__batchGetRfqOrderRelevantStatesInputOrdersStruct>,
    signatures: Array<
      IZeroEx__batchGetRfqOrderRelevantStatesInputSignaturesStruct
    >
  ): ethereum.CallResult<IZeroEx__batchGetRfqOrderRelevantStatesResult> {
    let result = super.tryCall(
      "batchGetRfqOrderRelevantStates",
      "batchGetRfqOrderRelevantStates((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256)[],(uint8,uint8,bytes32,bytes32)[]):((bytes32,uint8,uint128)[],uint128[],bool[])",
      [
        ethereum.Value.fromTupleArray(orders),
        ethereum.Value.fromTupleArray(signatures)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new IZeroEx__batchGetRfqOrderRelevantStatesResult(
        value[0].toTupleArray<
          IZeroEx__batchGetRfqOrderRelevantStatesResultOrderInfosStruct
        >(),
        value[1].toBigIntArray(),
        value[2].toBooleanArray()
      )
    );
  }

  createTransformWallet(): Address {
    let result = super.call(
      "createTransformWallet",
      "createTransformWallet():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_createTransformWallet(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "createTransformWallet",
      "createTransformWallet():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  fillOrKillRfqOrder(
    order: IZeroEx__fillOrKillRfqOrderInputOrderStruct,
    signature: IZeroEx__fillOrKillRfqOrderInputSignatureStruct,
    takerTokenFillAmount: BigInt
  ): BigInt {
    let result = super.call(
      "fillOrKillRfqOrder",
      "fillOrKillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128):(uint128)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromTuple(signature),
        ethereum.Value.fromUnsignedBigInt(takerTokenFillAmount)
      ]
    );

    return result[0].toBigInt();
  }

  try_fillOrKillRfqOrder(
    order: IZeroEx__fillOrKillRfqOrderInputOrderStruct,
    signature: IZeroEx__fillOrKillRfqOrderInputSignatureStruct,
    takerTokenFillAmount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "fillOrKillRfqOrder",
      "fillOrKillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128):(uint128)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromTuple(signature),
        ethereum.Value.fromUnsignedBigInt(takerTokenFillAmount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fillRfqOrder(
    order: IZeroEx__fillRfqOrderInputOrderStruct,
    signature: IZeroEx__fillRfqOrderInputSignatureStruct,
    takerTokenFillAmount: BigInt
  ): IZeroEx__fillRfqOrderResult {
    let result = super.call(
      "fillRfqOrder",
      "fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128):(uint128,uint128)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromTuple(signature),
        ethereum.Value.fromUnsignedBigInt(takerTokenFillAmount)
      ]
    );

    return new IZeroEx__fillRfqOrderResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_fillRfqOrder(
    order: IZeroEx__fillRfqOrderInputOrderStruct,
    signature: IZeroEx__fillRfqOrderInputSignatureStruct,
    takerTokenFillAmount: BigInt
  ): ethereum.CallResult<IZeroEx__fillRfqOrderResult> {
    let result = super.tryCall(
      "fillRfqOrder",
      "fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128):(uint128,uint128)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromTuple(signature),
        ethereum.Value.fromUnsignedBigInt(takerTokenFillAmount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new IZeroEx__fillRfqOrderResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  getAllowanceTarget(): Address {
    let result = super.call(
      "getAllowanceTarget",
      "getAllowanceTarget():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getAllowanceTarget(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getAllowanceTarget",
      "getAllowanceTarget():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getLimitOrderHash(order: IZeroEx__getLimitOrderHashInputOrderStruct): Bytes {
    let result = super.call(
      "getLimitOrderHash",
      "getLimitOrderHash((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256)):(bytes32)",
      [ethereum.Value.fromTuple(order)]
    );

    return result[0].toBytes();
  }

  try_getLimitOrderHash(
    order: IZeroEx__getLimitOrderHashInputOrderStruct
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getLimitOrderHash",
      "getLimitOrderHash((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256)):(bytes32)",
      [ethereum.Value.fromTuple(order)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getLimitOrderInfo(
    order: IZeroEx__getLimitOrderInfoInputOrderStruct
  ): IZeroEx__getLimitOrderInfoResultOrderInfoStruct {
    let result = super.call(
      "getLimitOrderInfo",
      "getLimitOrderInfo((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256)):((bytes32,uint8,uint128))",
      [ethereum.Value.fromTuple(order)]
    );

    return result[0].toTuple() as IZeroEx__getLimitOrderInfoResultOrderInfoStruct;
  }

  try_getLimitOrderInfo(
    order: IZeroEx__getLimitOrderInfoInputOrderStruct
  ): ethereum.CallResult<IZeroEx__getLimitOrderInfoResultOrderInfoStruct> {
    let result = super.tryCall(
      "getLimitOrderInfo",
      "getLimitOrderInfo((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256)):((bytes32,uint8,uint128))",
      [ethereum.Value.fromTuple(order)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as IZeroEx__getLimitOrderInfoResultOrderInfoStruct
    );
  }

  getLimitOrderRelevantState(
    order: IZeroEx__getLimitOrderRelevantStateInputOrderStruct,
    signature: IZeroEx__getLimitOrderRelevantStateInputSignatureStruct
  ): IZeroEx__getLimitOrderRelevantStateResult {
    let result = super.call(
      "getLimitOrderRelevantState",
      "getLimitOrderRelevantState((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32)):((bytes32,uint8,uint128),uint128,bool)",
      [ethereum.Value.fromTuple(order), ethereum.Value.fromTuple(signature)]
    );

    return new IZeroEx__getLimitOrderRelevantStateResult(
      result[0].toTuple() as IZeroEx__getLimitOrderRelevantStateResultOrderInfoStruct,
      result[1].toBigInt(),
      result[2].toBoolean()
    ) as IZeroEx__getLimitOrderRelevantStateResult;
  }

  try_getLimitOrderRelevantState(
    order: IZeroEx__getLimitOrderRelevantStateInputOrderStruct,
    signature: IZeroEx__getLimitOrderRelevantStateInputSignatureStruct
  ): ethereum.CallResult<IZeroEx__getLimitOrderRelevantStateResult> {
    let result = super.tryCall(
      "getLimitOrderRelevantState",
      "getLimitOrderRelevantState((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32)):((bytes32,uint8,uint128),uint128,bool)",
      [ethereum.Value.fromTuple(order), ethereum.Value.fromTuple(signature)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new IZeroEx__getLimitOrderRelevantStateResult(
        value[0].toTuple() as IZeroEx__getLimitOrderRelevantStateResultOrderInfoStruct,
        value[1].toBigInt(),
        value[2].toBoolean()
      ) as IZeroEx__getLimitOrderRelevantStateResult
    );
  }

  getMetaTransactionExecutedBlock(
    mtx: IZeroEx__getMetaTransactionExecutedBlockInputMtxStruct
  ): BigInt {
    let result = super.call(
      "getMetaTransactionExecutedBlock",
      "getMetaTransactionExecutedBlock((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256)):(uint256)",
      [ethereum.Value.fromTuple(mtx)]
    );

    return result[0].toBigInt();
  }

  try_getMetaTransactionExecutedBlock(
    mtx: IZeroEx__getMetaTransactionExecutedBlockInputMtxStruct
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getMetaTransactionExecutedBlock",
      "getMetaTransactionExecutedBlock((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256)):(uint256)",
      [ethereum.Value.fromTuple(mtx)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getMetaTransactionHash(
    mtx: IZeroEx__getMetaTransactionHashInputMtxStruct
  ): Bytes {
    let result = super.call(
      "getMetaTransactionHash",
      "getMetaTransactionHash((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256)):(bytes32)",
      [ethereum.Value.fromTuple(mtx)]
    );

    return result[0].toBytes();
  }

  try_getMetaTransactionHash(
    mtx: IZeroEx__getMetaTransactionHashInputMtxStruct
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getMetaTransactionHash",
      "getMetaTransactionHash((address,address,uint256,uint256,uint256,uint256,bytes,uint256,address,uint256)):(bytes32)",
      [ethereum.Value.fromTuple(mtx)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getMetaTransactionHashExecutedBlock(mtxHash: Bytes): BigInt {
    let result = super.call(
      "getMetaTransactionHashExecutedBlock",
      "getMetaTransactionHashExecutedBlock(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(mtxHash)]
    );

    return result[0].toBigInt();
  }

  try_getMetaTransactionHashExecutedBlock(
    mtxHash: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getMetaTransactionHashExecutedBlock",
      "getMetaTransactionHashExecutedBlock(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(mtxHash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getProtocolFeeMultiplier(): BigInt {
    let result = super.call(
      "getProtocolFeeMultiplier",
      "getProtocolFeeMultiplier():(uint32)",
      []
    );

    return result[0].toBigInt();
  }

  try_getProtocolFeeMultiplier(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getProtocolFeeMultiplier",
      "getProtocolFeeMultiplier():(uint32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getQuoteSigner(): Address {
    let result = super.call("getQuoteSigner", "getQuoteSigner():(address)", []);

    return result[0].toAddress();
  }

  try_getQuoteSigner(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getQuoteSigner",
      "getQuoteSigner():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getRfqOrderHash(order: IZeroEx__getRfqOrderHashInputOrderStruct): Bytes {
    let result = super.call(
      "getRfqOrderHash",
      "getRfqOrderHash((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256)):(bytes32)",
      [ethereum.Value.fromTuple(order)]
    );

    return result[0].toBytes();
  }

  try_getRfqOrderHash(
    order: IZeroEx__getRfqOrderHashInputOrderStruct
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getRfqOrderHash",
      "getRfqOrderHash((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256)):(bytes32)",
      [ethereum.Value.fromTuple(order)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getRfqOrderInfo(
    order: IZeroEx__getRfqOrderInfoInputOrderStruct
  ): IZeroEx__getRfqOrderInfoResultOrderInfoStruct {
    let result = super.call(
      "getRfqOrderInfo",
      "getRfqOrderInfo((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256)):((bytes32,uint8,uint128))",
      [ethereum.Value.fromTuple(order)]
    );

    return result[0].toTuple() as IZeroEx__getRfqOrderInfoResultOrderInfoStruct;
  }

  try_getRfqOrderInfo(
    order: IZeroEx__getRfqOrderInfoInputOrderStruct
  ): ethereum.CallResult<IZeroEx__getRfqOrderInfoResultOrderInfoStruct> {
    let result = super.tryCall(
      "getRfqOrderInfo",
      "getRfqOrderInfo((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256)):((bytes32,uint8,uint128))",
      [ethereum.Value.fromTuple(order)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as IZeroEx__getRfqOrderInfoResultOrderInfoStruct
    );
  }

  getRfqOrderRelevantState(
    order: IZeroEx__getRfqOrderRelevantStateInputOrderStruct,
    signature: IZeroEx__getRfqOrderRelevantStateInputSignatureStruct
  ): IZeroEx__getRfqOrderRelevantStateResult {
    let result = super.call(
      "getRfqOrderRelevantState",
      "getRfqOrderRelevantState((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32)):((bytes32,uint8,uint128),uint128,bool)",
      [ethereum.Value.fromTuple(order), ethereum.Value.fromTuple(signature)]
    );

    return new IZeroEx__getRfqOrderRelevantStateResult(
      result[0].toTuple() as IZeroEx__getRfqOrderRelevantStateResultOrderInfoStruct,
      result[1].toBigInt(),
      result[2].toBoolean()
    ) as IZeroEx__getRfqOrderRelevantStateResult;
  }

  try_getRfqOrderRelevantState(
    order: IZeroEx__getRfqOrderRelevantStateInputOrderStruct,
    signature: IZeroEx__getRfqOrderRelevantStateInputSignatureStruct
  ): ethereum.CallResult<IZeroEx__getRfqOrderRelevantStateResult> {
    let result = super.tryCall(
      "getRfqOrderRelevantState",
      "getRfqOrderRelevantState((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32)):((bytes32,uint8,uint128),uint128,bool)",
      [ethereum.Value.fromTuple(order), ethereum.Value.fromTuple(signature)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new IZeroEx__getRfqOrderRelevantStateResult(
        value[0].toTuple() as IZeroEx__getRfqOrderRelevantStateResultOrderInfoStruct,
        value[1].toBigInt(),
        value[2].toBoolean()
      ) as IZeroEx__getRfqOrderRelevantStateResult
    );
  }

  getRollbackEntryAtIndex(selector: Bytes, idx: BigInt): Address {
    let result = super.call(
      "getRollbackEntryAtIndex",
      "getRollbackEntryAtIndex(bytes4,uint256):(address)",
      [
        ethereum.Value.fromFixedBytes(selector),
        ethereum.Value.fromUnsignedBigInt(idx)
      ]
    );

    return result[0].toAddress();
  }

  try_getRollbackEntryAtIndex(
    selector: Bytes,
    idx: BigInt
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getRollbackEntryAtIndex",
      "getRollbackEntryAtIndex(bytes4,uint256):(address)",
      [
        ethereum.Value.fromFixedBytes(selector),
        ethereum.Value.fromUnsignedBigInt(idx)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getRollbackLength(selector: Bytes): BigInt {
    let result = super.call(
      "getRollbackLength",
      "getRollbackLength(bytes4):(uint256)",
      [ethereum.Value.fromFixedBytes(selector)]
    );

    return result[0].toBigInt();
  }

  try_getRollbackLength(selector: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getRollbackLength",
      "getRollbackLength(bytes4):(uint256)",
      [ethereum.Value.fromFixedBytes(selector)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getSpendableERC20BalanceOf(token: Address, owner: Address): BigInt {
    let result = super.call(
      "getSpendableERC20BalanceOf",
      "getSpendableERC20BalanceOf(address,address):(uint256)",
      [ethereum.Value.fromAddress(token), ethereum.Value.fromAddress(owner)]
    );

    return result[0].toBigInt();
  }

  try_getSpendableERC20BalanceOf(
    token: Address,
    owner: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getSpendableERC20BalanceOf",
      "getSpendableERC20BalanceOf(address,address):(uint256)",
      [ethereum.Value.fromAddress(token), ethereum.Value.fromAddress(owner)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTransformWallet(): Address {
    let result = super.call(
      "getTransformWallet",
      "getTransformWallet():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getTransformWallet(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getTransformWallet",
      "getTransformWallet():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getTransformerDeployer(): Address {
    let result = super.call(
      "getTransformerDeployer",
      "getTransformerDeployer():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getTransformerDeployer(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getTransformerDeployer",
      "getTransformerDeployer():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class _fillLimitOrderCall extends ethereum.Call {
  get inputs(): _fillLimitOrderCall__Inputs {
    return new _fillLimitOrderCall__Inputs(this);
  }

  get outputs(): _fillLimitOrderCall__Outputs {
    return new _fillLimitOrderCall__Outputs(this);
  }
}

export class _fillLimitOrderCall__Inputs {
  _call: _fillLimitOrderCall;

  constructor(call: _fillLimitOrderCall) {
    this._call = call;
  }

  get order(): _fillLimitOrderCallOrderStruct {
    return this._call.inputValues[0].value.toTuple() as _fillLimitOrderCallOrderStruct;
  }

  get signature(): _fillLimitOrderCallSignatureStruct {
    return this._call.inputValues[1].value.toTuple() as _fillLimitOrderCallSignatureStruct;
  }

  get takerTokenFillAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get taker(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get sender(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class _fillLimitOrderCall__Outputs {
  _call: _fillLimitOrderCall;

  constructor(call: _fillLimitOrderCall) {
    this._call = call;
  }

  get takerTokenFilledAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get makerTokenFilledAmount(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class _fillLimitOrderCallOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[4].toBigInt();
  }

  get maker(): Address {
    return this[5].toAddress();
  }

  get taker(): Address {
    return this[6].toAddress();
  }

  get sender(): Address {
    return this[7].toAddress();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get pool(): Bytes {
    return this[9].toBytes();
  }

  get expiry(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }
}

export class _fillLimitOrderCallSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class _fillRfqOrderCall extends ethereum.Call {
  get inputs(): _fillRfqOrderCall__Inputs {
    return new _fillRfqOrderCall__Inputs(this);
  }

  get outputs(): _fillRfqOrderCall__Outputs {
    return new _fillRfqOrderCall__Outputs(this);
  }
}

export class _fillRfqOrderCall__Inputs {
  _call: _fillRfqOrderCall;

  constructor(call: _fillRfqOrderCall) {
    this._call = call;
  }

  get order(): _fillRfqOrderCallOrderStruct {
    return this._call.inputValues[0].value.toTuple() as _fillRfqOrderCallOrderStruct;
  }

  get signature(): _fillRfqOrderCallSignatureStruct {
    return this._call.inputValues[1].value.toTuple() as _fillRfqOrderCallSignatureStruct;
  }

  get takerTokenFillAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get taker(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class _fillRfqOrderCall__Outputs {
  _call: _fillRfqOrderCall;

  constructor(call: _fillRfqOrderCall) {
    this._call = call;
  }

  get takerTokenFilledAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get makerTokenFilledAmount(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class _fillRfqOrderCallOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class _fillRfqOrderCallSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class _spendERC20TokensCall extends ethereum.Call {
  get inputs(): _spendERC20TokensCall__Inputs {
    return new _spendERC20TokensCall__Inputs(this);
  }

  get outputs(): _spendERC20TokensCall__Outputs {
    return new _spendERC20TokensCall__Outputs(this);
  }
}

export class _spendERC20TokensCall__Inputs {
  _call: _spendERC20TokensCall;

  constructor(call: _spendERC20TokensCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get owner(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class _spendERC20TokensCall__Outputs {
  _call: _spendERC20TokensCall;

  constructor(call: _spendERC20TokensCall) {
    this._call = call;
  }
}

export class _transformERC20Call extends ethereum.Call {
  get inputs(): _transformERC20Call__Inputs {
    return new _transformERC20Call__Inputs(this);
  }

  get outputs(): _transformERC20Call__Outputs {
    return new _transformERC20Call__Outputs(this);
  }
}

export class _transformERC20Call__Inputs {
  _call: _transformERC20Call;

  constructor(call: _transformERC20Call) {
    this._call = call;
  }

  get args(): _transformERC20CallArgsStruct {
    return this._call.inputValues[0].value.toTuple() as _transformERC20CallArgsStruct;
  }
}

export class _transformERC20Call__Outputs {
  _call: _transformERC20Call;

  constructor(call: _transformERC20Call) {
    this._call = call;
  }

  get outputTokenAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class _transformERC20CallArgsStruct extends ethereum.Tuple {
  get taker(): Address {
    return this[0].toAddress();
  }

  get inputToken(): Address {
    return this[1].toAddress();
  }

  get outputToken(): Address {
    return this[2].toAddress();
  }

  get inputTokenAmount(): BigInt {
    return this[3].toBigInt();
  }

  get minOutputTokenAmount(): BigInt {
    return this[4].toBigInt();
  }

  get transformations(): Array<_transformERC20CallArgsTransformationsStruct> {
    return this[5].toTupleArray<_transformERC20CallArgsTransformationsStruct>();
  }
}

export class _transformERC20CallArgsTransformationsStruct extends ethereum.Tuple {
  get deploymentNonce(): BigInt {
    return this[0].toBigInt();
  }

  get data(): Bytes {
    return this[1].toBytes();
  }
}

export class BatchCancelLimitOrdersCall extends ethereum.Call {
  get inputs(): BatchCancelLimitOrdersCall__Inputs {
    return new BatchCancelLimitOrdersCall__Inputs(this);
  }

  get outputs(): BatchCancelLimitOrdersCall__Outputs {
    return new BatchCancelLimitOrdersCall__Outputs(this);
  }
}

export class BatchCancelLimitOrdersCall__Inputs {
  _call: BatchCancelLimitOrdersCall;

  constructor(call: BatchCancelLimitOrdersCall) {
    this._call = call;
  }

  get orders(): Array<BatchCancelLimitOrdersCallOrdersStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      BatchCancelLimitOrdersCallOrdersStruct
    >();
  }
}

export class BatchCancelLimitOrdersCall__Outputs {
  _call: BatchCancelLimitOrdersCall;

  constructor(call: BatchCancelLimitOrdersCall) {
    this._call = call;
  }
}

export class BatchCancelLimitOrdersCallOrdersStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[4].toBigInt();
  }

  get maker(): Address {
    return this[5].toAddress();
  }

  get taker(): Address {
    return this[6].toAddress();
  }

  get sender(): Address {
    return this[7].toAddress();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get pool(): Bytes {
    return this[9].toBytes();
  }

  get expiry(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }
}

export class BatchCancelPairLimitOrdersCall extends ethereum.Call {
  get inputs(): BatchCancelPairLimitOrdersCall__Inputs {
    return new BatchCancelPairLimitOrdersCall__Inputs(this);
  }

  get outputs(): BatchCancelPairLimitOrdersCall__Outputs {
    return new BatchCancelPairLimitOrdersCall__Outputs(this);
  }
}

export class BatchCancelPairLimitOrdersCall__Inputs {
  _call: BatchCancelPairLimitOrdersCall;

  constructor(call: BatchCancelPairLimitOrdersCall) {
    this._call = call;
  }

  get makerTokens(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get takerTokens(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }

  get minValidSalts(): Array<BigInt> {
    return this._call.inputValues[2].value.toBigIntArray();
  }
}

export class BatchCancelPairLimitOrdersCall__Outputs {
  _call: BatchCancelPairLimitOrdersCall;

  constructor(call: BatchCancelPairLimitOrdersCall) {
    this._call = call;
  }
}

export class BatchCancelPairRfqOrdersCall extends ethereum.Call {
  get inputs(): BatchCancelPairRfqOrdersCall__Inputs {
    return new BatchCancelPairRfqOrdersCall__Inputs(this);
  }

  get outputs(): BatchCancelPairRfqOrdersCall__Outputs {
    return new BatchCancelPairRfqOrdersCall__Outputs(this);
  }
}

export class BatchCancelPairRfqOrdersCall__Inputs {
  _call: BatchCancelPairRfqOrdersCall;

  constructor(call: BatchCancelPairRfqOrdersCall) {
    this._call = call;
  }

  get makerTokens(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get takerTokens(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }

  get minValidSalts(): Array<BigInt> {
    return this._call.inputValues[2].value.toBigIntArray();
  }
}

export class BatchCancelPairRfqOrdersCall__Outputs {
  _call: BatchCancelPairRfqOrdersCall;

  constructor(call: BatchCancelPairRfqOrdersCall) {
    this._call = call;
  }
}

export class BatchCancelRfqOrdersCall extends ethereum.Call {
  get inputs(): BatchCancelRfqOrdersCall__Inputs {
    return new BatchCancelRfqOrdersCall__Inputs(this);
  }

  get outputs(): BatchCancelRfqOrdersCall__Outputs {
    return new BatchCancelRfqOrdersCall__Outputs(this);
  }
}

export class BatchCancelRfqOrdersCall__Inputs {
  _call: BatchCancelRfqOrdersCall;

  constructor(call: BatchCancelRfqOrdersCall) {
    this._call = call;
  }

  get orders(): Array<BatchCancelRfqOrdersCallOrdersStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      BatchCancelRfqOrdersCallOrdersStruct
    >();
  }
}

export class BatchCancelRfqOrdersCall__Outputs {
  _call: BatchCancelRfqOrdersCall;

  constructor(call: BatchCancelRfqOrdersCall) {
    this._call = call;
  }
}

export class BatchCancelRfqOrdersCallOrdersStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class BatchExecuteMetaTransactionsCall extends ethereum.Call {
  get inputs(): BatchExecuteMetaTransactionsCall__Inputs {
    return new BatchExecuteMetaTransactionsCall__Inputs(this);
  }

  get outputs(): BatchExecuteMetaTransactionsCall__Outputs {
    return new BatchExecuteMetaTransactionsCall__Outputs(this);
  }
}

export class BatchExecuteMetaTransactionsCall__Inputs {
  _call: BatchExecuteMetaTransactionsCall;

  constructor(call: BatchExecuteMetaTransactionsCall) {
    this._call = call;
  }

  get mtxs(): Array<BatchExecuteMetaTransactionsCallMtxsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      BatchExecuteMetaTransactionsCallMtxsStruct
    >();
  }

  get signatures(): Array<BatchExecuteMetaTransactionsCallSignaturesStruct> {
    return this._call.inputValues[1].value.toTupleArray<
      BatchExecuteMetaTransactionsCallSignaturesStruct
    >();
  }
}

export class BatchExecuteMetaTransactionsCall__Outputs {
  _call: BatchExecuteMetaTransactionsCall;

  constructor(call: BatchExecuteMetaTransactionsCall) {
    this._call = call;
  }

  get returnResults(): Array<Bytes> {
    return this._call.outputValues[0].value.toBytesArray();
  }
}

export class BatchExecuteMetaTransactionsCallMtxsStruct extends ethereum.Tuple {
  get signer(): Address {
    return this[0].toAddress();
  }

  get sender(): Address {
    return this[1].toAddress();
  }

  get minGasPrice(): BigInt {
    return this[2].toBigInt();
  }

  get maxGasPrice(): BigInt {
    return this[3].toBigInt();
  }

  get expirationTimeSeconds(): BigInt {
    return this[4].toBigInt();
  }

  get salt(): BigInt {
    return this[5].toBigInt();
  }

  get callData(): Bytes {
    return this[6].toBytes();
  }

  get value(): BigInt {
    return this[7].toBigInt();
  }

  get feeToken(): Address {
    return this[8].toAddress();
  }

  get feeAmount(): BigInt {
    return this[9].toBigInt();
  }
}

export class BatchExecuteMetaTransactionsCallSignaturesStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class CancelLimitOrderCall extends ethereum.Call {
  get inputs(): CancelLimitOrderCall__Inputs {
    return new CancelLimitOrderCall__Inputs(this);
  }

  get outputs(): CancelLimitOrderCall__Outputs {
    return new CancelLimitOrderCall__Outputs(this);
  }
}

export class CancelLimitOrderCall__Inputs {
  _call: CancelLimitOrderCall;

  constructor(call: CancelLimitOrderCall) {
    this._call = call;
  }

  get order(): CancelLimitOrderCallOrderStruct {
    return this._call.inputValues[0].value.toTuple() as CancelLimitOrderCallOrderStruct;
  }
}

export class CancelLimitOrderCall__Outputs {
  _call: CancelLimitOrderCall;

  constructor(call: CancelLimitOrderCall) {
    this._call = call;
  }
}

export class CancelLimitOrderCallOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[4].toBigInt();
  }

  get maker(): Address {
    return this[5].toAddress();
  }

  get taker(): Address {
    return this[6].toAddress();
  }

  get sender(): Address {
    return this[7].toAddress();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get pool(): Bytes {
    return this[9].toBytes();
  }

  get expiry(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }
}

export class CancelPairLimitOrdersCall extends ethereum.Call {
  get inputs(): CancelPairLimitOrdersCall__Inputs {
    return new CancelPairLimitOrdersCall__Inputs(this);
  }

  get outputs(): CancelPairLimitOrdersCall__Outputs {
    return new CancelPairLimitOrdersCall__Outputs(this);
  }
}

export class CancelPairLimitOrdersCall__Inputs {
  _call: CancelPairLimitOrdersCall;

  constructor(call: CancelPairLimitOrdersCall) {
    this._call = call;
  }

  get makerToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get takerToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get minValidSalt(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class CancelPairLimitOrdersCall__Outputs {
  _call: CancelPairLimitOrdersCall;

  constructor(call: CancelPairLimitOrdersCall) {
    this._call = call;
  }
}

export class CancelPairRfqOrdersCall extends ethereum.Call {
  get inputs(): CancelPairRfqOrdersCall__Inputs {
    return new CancelPairRfqOrdersCall__Inputs(this);
  }

  get outputs(): CancelPairRfqOrdersCall__Outputs {
    return new CancelPairRfqOrdersCall__Outputs(this);
  }
}

export class CancelPairRfqOrdersCall__Inputs {
  _call: CancelPairRfqOrdersCall;

  constructor(call: CancelPairRfqOrdersCall) {
    this._call = call;
  }

  get makerToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get takerToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get minValidSalt(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class CancelPairRfqOrdersCall__Outputs {
  _call: CancelPairRfqOrdersCall;

  constructor(call: CancelPairRfqOrdersCall) {
    this._call = call;
  }
}

export class CancelRfqOrderCall extends ethereum.Call {
  get inputs(): CancelRfqOrderCall__Inputs {
    return new CancelRfqOrderCall__Inputs(this);
  }

  get outputs(): CancelRfqOrderCall__Outputs {
    return new CancelRfqOrderCall__Outputs(this);
  }
}

export class CancelRfqOrderCall__Inputs {
  _call: CancelRfqOrderCall;

  constructor(call: CancelRfqOrderCall) {
    this._call = call;
  }

  get order(): CancelRfqOrderCallOrderStruct {
    return this._call.inputValues[0].value.toTuple() as CancelRfqOrderCallOrderStruct;
  }
}

export class CancelRfqOrderCall__Outputs {
  _call: CancelRfqOrderCall;

  constructor(call: CancelRfqOrderCall) {
    this._call = call;
  }
}

export class CancelRfqOrderCallOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class CreateTransformWalletCall extends ethereum.Call {
  get inputs(): CreateTransformWalletCall__Inputs {
    return new CreateTransformWalletCall__Inputs(this);
  }

  get outputs(): CreateTransformWalletCall__Outputs {
    return new CreateTransformWalletCall__Outputs(this);
  }
}

export class CreateTransformWalletCall__Inputs {
  _call: CreateTransformWalletCall;

  constructor(call: CreateTransformWalletCall) {
    this._call = call;
  }
}

export class CreateTransformWalletCall__Outputs {
  _call: CreateTransformWalletCall;

  constructor(call: CreateTransformWalletCall) {
    this._call = call;
  }

  get wallet(): Address {
    return this._call.outputValues[0].value.toAddress();
  }
}

export class ExecuteMetaTransactionCall extends ethereum.Call {
  get inputs(): ExecuteMetaTransactionCall__Inputs {
    return new ExecuteMetaTransactionCall__Inputs(this);
  }

  get outputs(): ExecuteMetaTransactionCall__Outputs {
    return new ExecuteMetaTransactionCall__Outputs(this);
  }
}

export class ExecuteMetaTransactionCall__Inputs {
  _call: ExecuteMetaTransactionCall;

  constructor(call: ExecuteMetaTransactionCall) {
    this._call = call;
  }

  get mtx(): ExecuteMetaTransactionCallMtxStruct {
    return this._call.inputValues[0].value.toTuple() as ExecuteMetaTransactionCallMtxStruct;
  }

  get signature(): ExecuteMetaTransactionCallSignatureStruct {
    return this._call.inputValues[1].value.toTuple() as ExecuteMetaTransactionCallSignatureStruct;
  }
}

export class ExecuteMetaTransactionCall__Outputs {
  _call: ExecuteMetaTransactionCall;

  constructor(call: ExecuteMetaTransactionCall) {
    this._call = call;
  }

  get returnResult(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class ExecuteMetaTransactionCallMtxStruct extends ethereum.Tuple {
  get signer(): Address {
    return this[0].toAddress();
  }

  get sender(): Address {
    return this[1].toAddress();
  }

  get minGasPrice(): BigInt {
    return this[2].toBigInt();
  }

  get maxGasPrice(): BigInt {
    return this[3].toBigInt();
  }

  get expirationTimeSeconds(): BigInt {
    return this[4].toBigInt();
  }

  get salt(): BigInt {
    return this[5].toBigInt();
  }

  get callData(): Bytes {
    return this[6].toBytes();
  }

  get value(): BigInt {
    return this[7].toBigInt();
  }

  get feeToken(): Address {
    return this[8].toAddress();
  }

  get feeAmount(): BigInt {
    return this[9].toBigInt();
  }
}

export class ExecuteMetaTransactionCallSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class ExtendCall extends ethereum.Call {
  get inputs(): ExtendCall__Inputs {
    return new ExtendCall__Inputs(this);
  }

  get outputs(): ExtendCall__Outputs {
    return new ExtendCall__Outputs(this);
  }
}

export class ExtendCall__Inputs {
  _call: ExtendCall;

  constructor(call: ExtendCall) {
    this._call = call;
  }

  get selector(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get impl(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class ExtendCall__Outputs {
  _call: ExtendCall;

  constructor(call: ExtendCall) {
    this._call = call;
  }
}

export class FillLimitOrderCall extends ethereum.Call {
  get inputs(): FillLimitOrderCall__Inputs {
    return new FillLimitOrderCall__Inputs(this);
  }

  get outputs(): FillLimitOrderCall__Outputs {
    return new FillLimitOrderCall__Outputs(this);
  }
}

export class FillLimitOrderCall__Inputs {
  _call: FillLimitOrderCall;

  constructor(call: FillLimitOrderCall) {
    this._call = call;
  }

  get order(): FillLimitOrderCallOrderStruct {
    return this._call.inputValues[0].value.toTuple() as FillLimitOrderCallOrderStruct;
  }

  get signature(): FillLimitOrderCallSignatureStruct {
    return this._call.inputValues[1].value.toTuple() as FillLimitOrderCallSignatureStruct;
  }

  get takerTokenFillAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class FillLimitOrderCall__Outputs {
  _call: FillLimitOrderCall;

  constructor(call: FillLimitOrderCall) {
    this._call = call;
  }

  get takerTokenFilledAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get makerTokenFilledAmount(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class FillLimitOrderCallOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[4].toBigInt();
  }

  get maker(): Address {
    return this[5].toAddress();
  }

  get taker(): Address {
    return this[6].toAddress();
  }

  get sender(): Address {
    return this[7].toAddress();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get pool(): Bytes {
    return this[9].toBytes();
  }

  get expiry(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }
}

export class FillLimitOrderCallSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class FillOrKillLimitOrderCall extends ethereum.Call {
  get inputs(): FillOrKillLimitOrderCall__Inputs {
    return new FillOrKillLimitOrderCall__Inputs(this);
  }

  get outputs(): FillOrKillLimitOrderCall__Outputs {
    return new FillOrKillLimitOrderCall__Outputs(this);
  }
}

export class FillOrKillLimitOrderCall__Inputs {
  _call: FillOrKillLimitOrderCall;

  constructor(call: FillOrKillLimitOrderCall) {
    this._call = call;
  }

  get order(): FillOrKillLimitOrderCallOrderStruct {
    return this._call.inputValues[0].value.toTuple() as FillOrKillLimitOrderCallOrderStruct;
  }

  get signature(): FillOrKillLimitOrderCallSignatureStruct {
    return this._call.inputValues[1].value.toTuple() as FillOrKillLimitOrderCallSignatureStruct;
  }

  get takerTokenFillAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class FillOrKillLimitOrderCall__Outputs {
  _call: FillOrKillLimitOrderCall;

  constructor(call: FillOrKillLimitOrderCall) {
    this._call = call;
  }

  get makerTokenFilledAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class FillOrKillLimitOrderCallOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[4].toBigInt();
  }

  get maker(): Address {
    return this[5].toAddress();
  }

  get taker(): Address {
    return this[6].toAddress();
  }

  get sender(): Address {
    return this[7].toAddress();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get pool(): Bytes {
    return this[9].toBytes();
  }

  get expiry(): BigInt {
    return this[10].toBigInt();
  }

  get salt(): BigInt {
    return this[11].toBigInt();
  }
}

export class FillOrKillLimitOrderCallSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class FillOrKillRfqOrderCall extends ethereum.Call {
  get inputs(): FillOrKillRfqOrderCall__Inputs {
    return new FillOrKillRfqOrderCall__Inputs(this);
  }

  get outputs(): FillOrKillRfqOrderCall__Outputs {
    return new FillOrKillRfqOrderCall__Outputs(this);
  }
}

export class FillOrKillRfqOrderCall__Inputs {
  _call: FillOrKillRfqOrderCall;

  constructor(call: FillOrKillRfqOrderCall) {
    this._call = call;
  }

  get order(): FillOrKillRfqOrderCallOrderStruct {
    return this._call.inputValues[0].value.toTuple() as FillOrKillRfqOrderCallOrderStruct;
  }

  get signature(): FillOrKillRfqOrderCallSignatureStruct {
    return this._call.inputValues[1].value.toTuple() as FillOrKillRfqOrderCallSignatureStruct;
  }

  get takerTokenFillAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class FillOrKillRfqOrderCall__Outputs {
  _call: FillOrKillRfqOrderCall;

  constructor(call: FillOrKillRfqOrderCall) {
    this._call = call;
  }

  get makerTokenFilledAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class FillOrKillRfqOrderCallOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class FillOrKillRfqOrderCallSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class FillRfqOrderCall extends ethereum.Call {
  get inputs(): FillRfqOrderCall__Inputs {
    return new FillRfqOrderCall__Inputs(this);
  }

  get outputs(): FillRfqOrderCall__Outputs {
    return new FillRfqOrderCall__Outputs(this);
  }
}

export class FillRfqOrderCall__Inputs {
  _call: FillRfqOrderCall;

  constructor(call: FillRfqOrderCall) {
    this._call = call;
  }

  get order(): FillRfqOrderCallOrderStruct {
    return this._call.inputValues[0].value.toTuple() as FillRfqOrderCallOrderStruct;
  }

  get signature(): FillRfqOrderCallSignatureStruct {
    return this._call.inputValues[1].value.toTuple() as FillRfqOrderCallSignatureStruct;
  }

  get takerTokenFillAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class FillRfqOrderCall__Outputs {
  _call: FillRfqOrderCall;

  constructor(call: FillRfqOrderCall) {
    this._call = call;
  }

  get takerTokenFilledAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get makerTokenFilledAmount(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class FillRfqOrderCallOrderStruct extends ethereum.Tuple {
  get makerToken(): Address {
    return this[0].toAddress();
  }

  get takerToken(): Address {
    return this[1].toAddress();
  }

  get makerAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takerAmount(): BigInt {
    return this[3].toBigInt();
  }

  get maker(): Address {
    return this[4].toAddress();
  }

  get taker(): Address {
    return this[5].toAddress();
  }

  get txOrigin(): Address {
    return this[6].toAddress();
  }

  get pool(): Bytes {
    return this[7].toBytes();
  }

  get expiry(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }
}

export class FillRfqOrderCallSignatureStruct extends ethereum.Tuple {
  get signatureType(): i32 {
    return this[0].toI32();
  }

  get v(): i32 {
    return this[1].toI32();
  }

  get r(): Bytes {
    return this[2].toBytes();
  }

  get s(): Bytes {
    return this[3].toBytes();
  }
}

export class MigrateCall extends ethereum.Call {
  get inputs(): MigrateCall__Inputs {
    return new MigrateCall__Inputs(this);
  }

  get outputs(): MigrateCall__Outputs {
    return new MigrateCall__Outputs(this);
  }
}

export class MigrateCall__Inputs {
  _call: MigrateCall;

  constructor(call: MigrateCall) {
    this._call = call;
  }

  get target(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get data(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get newOwner(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class MigrateCall__Outputs {
  _call: MigrateCall;

  constructor(call: MigrateCall) {
    this._call = call;
  }
}

export class RegisterAllowedRfqOriginsCall extends ethereum.Call {
  get inputs(): RegisterAllowedRfqOriginsCall__Inputs {
    return new RegisterAllowedRfqOriginsCall__Inputs(this);
  }

  get outputs(): RegisterAllowedRfqOriginsCall__Outputs {
    return new RegisterAllowedRfqOriginsCall__Outputs(this);
  }
}

export class RegisterAllowedRfqOriginsCall__Inputs {
  _call: RegisterAllowedRfqOriginsCall;

  constructor(call: RegisterAllowedRfqOriginsCall) {
    this._call = call;
  }

  get origins(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get allowed(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class RegisterAllowedRfqOriginsCall__Outputs {
  _call: RegisterAllowedRfqOriginsCall;

  constructor(call: RegisterAllowedRfqOriginsCall) {
    this._call = call;
  }
}

export class RollbackCall extends ethereum.Call {
  get inputs(): RollbackCall__Inputs {
    return new RollbackCall__Inputs(this);
  }

  get outputs(): RollbackCall__Outputs {
    return new RollbackCall__Outputs(this);
  }
}

export class RollbackCall__Inputs {
  _call: RollbackCall;

  constructor(call: RollbackCall) {
    this._call = call;
  }

  get selector(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get targetImpl(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RollbackCall__Outputs {
  _call: RollbackCall;

  constructor(call: RollbackCall) {
    this._call = call;
  }
}

export class SellToLiquidityProviderCall extends ethereum.Call {
  get inputs(): SellToLiquidityProviderCall__Inputs {
    return new SellToLiquidityProviderCall__Inputs(this);
  }

  get outputs(): SellToLiquidityProviderCall__Outputs {
    return new SellToLiquidityProviderCall__Outputs(this);
  }
}

export class SellToLiquidityProviderCall__Inputs {
  _call: SellToLiquidityProviderCall;

  constructor(call: SellToLiquidityProviderCall) {
    this._call = call;
  }

  get inputToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get outputToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get provider(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get sellAmount(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get minBuyAmount(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get auxiliaryData(): Bytes {
    return this._call.inputValues[6].value.toBytes();
  }
}

export class SellToLiquidityProviderCall__Outputs {
  _call: SellToLiquidityProviderCall;

  constructor(call: SellToLiquidityProviderCall) {
    this._call = call;
  }

  get boughtAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SellToUniswapCall extends ethereum.Call {
  get inputs(): SellToUniswapCall__Inputs {
    return new SellToUniswapCall__Inputs(this);
  }

  get outputs(): SellToUniswapCall__Outputs {
    return new SellToUniswapCall__Outputs(this);
  }
}

export class SellToUniswapCall__Inputs {
  _call: SellToUniswapCall;

  constructor(call: SellToUniswapCall) {
    this._call = call;
  }

  get tokens(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get sellAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get minBuyAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get isSushi(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }
}

export class SellToUniswapCall__Outputs {
  _call: SellToUniswapCall;

  constructor(call: SellToUniswapCall) {
    this._call = call;
  }

  get buyAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SetQuoteSignerCall extends ethereum.Call {
  get inputs(): SetQuoteSignerCall__Inputs {
    return new SetQuoteSignerCall__Inputs(this);
  }

  get outputs(): SetQuoteSignerCall__Outputs {
    return new SetQuoteSignerCall__Outputs(this);
  }
}

export class SetQuoteSignerCall__Inputs {
  _call: SetQuoteSignerCall;

  constructor(call: SetQuoteSignerCall) {
    this._call = call;
  }

  get quoteSigner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetQuoteSignerCall__Outputs {
  _call: SetQuoteSignerCall;

  constructor(call: SetQuoteSignerCall) {
    this._call = call;
  }
}

export class SetTransformerDeployerCall extends ethereum.Call {
  get inputs(): SetTransformerDeployerCall__Inputs {
    return new SetTransformerDeployerCall__Inputs(this);
  }

  get outputs(): SetTransformerDeployerCall__Outputs {
    return new SetTransformerDeployerCall__Outputs(this);
  }
}

export class SetTransformerDeployerCall__Inputs {
  _call: SetTransformerDeployerCall;

  constructor(call: SetTransformerDeployerCall) {
    this._call = call;
  }

  get transformerDeployer(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetTransformerDeployerCall__Outputs {
  _call: SetTransformerDeployerCall;

  constructor(call: SetTransformerDeployerCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class TransferProtocolFeesForPoolsCall extends ethereum.Call {
  get inputs(): TransferProtocolFeesForPoolsCall__Inputs {
    return new TransferProtocolFeesForPoolsCall__Inputs(this);
  }

  get outputs(): TransferProtocolFeesForPoolsCall__Outputs {
    return new TransferProtocolFeesForPoolsCall__Outputs(this);
  }
}

export class TransferProtocolFeesForPoolsCall__Inputs {
  _call: TransferProtocolFeesForPoolsCall;

  constructor(call: TransferProtocolFeesForPoolsCall) {
    this._call = call;
  }

  get poolIds(): Array<Bytes> {
    return this._call.inputValues[0].value.toBytesArray();
  }
}

export class TransferProtocolFeesForPoolsCall__Outputs {
  _call: TransferProtocolFeesForPoolsCall;

  constructor(call: TransferProtocolFeesForPoolsCall) {
    this._call = call;
  }
}

export class TransformERC20Call extends ethereum.Call {
  get inputs(): TransformERC20Call__Inputs {
    return new TransformERC20Call__Inputs(this);
  }

  get outputs(): TransformERC20Call__Outputs {
    return new TransformERC20Call__Outputs(this);
  }
}

export class TransformERC20Call__Inputs {
  _call: TransformERC20Call;

  constructor(call: TransformERC20Call) {
    this._call = call;
  }

  get inputToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get outputToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get inputTokenAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get minOutputTokenAmount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get transformations(): Array<TransformERC20CallTransformationsStruct> {
    return this._call.inputValues[4].value.toTupleArray<
      TransformERC20CallTransformationsStruct
    >();
  }
}

export class TransformERC20Call__Outputs {
  _call: TransformERC20Call;

  constructor(call: TransformERC20Call) {
    this._call = call;
  }

  get outputTokenAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TransformERC20CallTransformationsStruct extends ethereum.Tuple {
  get deploymentNonce(): BigInt {
    return this[0].toBigInt();
  }

  get data(): Bytes {
    return this[1].toBytes();
  }
}
